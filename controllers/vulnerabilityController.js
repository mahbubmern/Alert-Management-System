import asyncHandler from "express-async-handler";

import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import {
  generateOTP,
  getPublicID,
  isValidEmail,
  isValidPassword,
  isValidPhoneNumber,
  tokenDecode,
} from "../helpers/helpers.js";
import { Vulnerability, Counter } from "../models/vulnerabilityModel.js";
// import Counter from "../models/counter.js";

//===========================================================

/**
 * @description : vulnerability
 * @method : POST
 * @access : private
 * @route : '/api/v1/auth/vulnerability'
 */

// Allowed lists for validation
const allowedSeverity = ["Low", "Medium", "High", "Critical"];
const allowedStatus = [
  "Open",
  "In Progress",
  "Resolved",
  "Closed",
  "Risk Accepted",
];
const allowedAssetCategory = [
  "Production",
  "Staging",
  "Development",
  "Testing",

  "UAT",
  "Internal Infra",
];
const allowedScanType = [
  "Network Scan",
  "App Scan",
  "Database Scan",
  "Config Scan",
  "Host Scan",
];

export const addVulnerability = asyncHandler(async (req, res) => {
  const {
    name,
    service,
    severity,
    status,
    asset,
    assetCategory,
    osType,
    scanType,
    cve,
    scanner,
    scanTime,
    description,
    remediation,
  } = req.body;

  // ğŸ§© Field validation
  if (
    !name?.trim() ||
    !service?.trim() ||
    !severity?.trim() ||
    !status?.trim() ||
    !asset?.trim() ||
    !assetCategory?.trim() ||
    !osType?.trim() ||
    !scanType?.trim() ||
    !cve?.trim() ||
    !scanner?.trim() ||
    !description?.trim() ||
    !remediation?.trim()
  ) {
    return res.status(400).json({ message: "All fields are required" });
  }

  // ğŸ›‘ ENUM mismatch validation
  if (!allowedSeverity.includes(severity)) {
    return res.status(400).json({
      message: `Invalid severity value. Allowed: ${allowedSeverity.join(", ")}`,
    });
  }

  if (!allowedStatus.includes(status)) {
    return res.status(400).json({
      message: `Invalid status value. Allowed: ${allowedStatus.join(", ")}`,
    });
  }

  if (!allowedAssetCategory.includes(assetCategory)) {
    return res.status(400).json({
      message: `Invalid asset category. Allowed: ${allowedAssetCategory.join(
        ", "
      )}`,
    });
  }

  if (!allowedScanType.includes(scanType)) {
    return res.status(400).json({
      message: `Invalid scan type. Allowed: ${allowedScanType.join(", ")}`,
    });
  }

  try {
    // ğŸ§± Create new vulnerability
    const newVulnerability = await Vulnerability.create({
      name,
      service,
      severity,
      status,
      asset,
      assetCategory,
      osType,
      scanType,
      cve,
      scanner,
      scanTime: scanTime || new Date(),
      description,
      remediation,
    });

    // âœ… Response
    res.status(201).json({
      success: true,
      message: "Vulnerability added successfully",
      data: newVulnerability,
    });
  } catch (error) {
    console.error("âŒ Failed to create vulnerability:", error);
    res.status(500).json({ message: "Failed to create vulnerability", error });
  }
});

// get All vulnerability

export const getAllVulnerabilityController = asyncHandler(async (req, res) => {
  const allVulnerability = await Vulnerability.find().sort({ createdAt: -1 });

  // âœ… Response
  res.status(200).json({
    success: true,
    message: "Vulnerability found successfully",
    data: allVulnerability,
  });
});

// // get All vulnerability

export const bulkAddVulnerability = asyncHandler(async (req, res) => {
  const { vulnerabilities } = req.body;

  if (!Array.isArray(vulnerabilities) || vulnerabilities.length === 0) {
    return res.status(400).json({ message: "No vulnerabilities provided" });
  }

  // ğŸ§© Validate each entry
  for (const vuln of vulnerabilities) {
    const {
      name,
      service,
      severity,
      status,
      asset,
      assetCategory,
      osType,
      scanType,
      cve,
      scanner,
      scanTime,
      description,
      remediation,
    } = vuln;

    if (
      !name?.trim() ||
      !service?.trim() ||
      !severity?.trim() ||
      !status?.trim() ||
      !asset?.trim() ||
      !assetCategory?.trim() ||
      !osType?.trim() ||
      !scanType?.trim() ||
      !cve?.trim() ||
      !scanner?.trim() ||
      !description?.trim() ||
      !remediation?.trim()
    ) {
      return res.status(400).json({
        message: `Missing required field(s) in one of the vulnerabilities`,
      });
    }

    if (!allowedSeverity.includes(severity))
      return res.status(400).json({ message: `Invalid severity: ${severity}` });

    if (!allowedStatus.includes(status))
      return res.status(400).json({ message: `Invalid status: ${status}` });

    if (!allowedAssetCategory.includes(assetCategory))
      return res
        .status(400)
        .json({ message: `Invalid asset category: ${assetCategory}` });

    if (!allowedScanType.includes(scanType))
      return res
        .status(400)
        .json({ message: `Invalid scan type: ${scanType}` });
  }

  try {
    // Get the current counter value
    const counter = await Counter.findByIdAndUpdate(
      { _id: "vulnerabilityId" },
      { $inc: { seq: vulnerabilities.length } },
      { new: true, upsert: true }
    );

    let startSeq = counter.seq - vulnerabilities.length + 1;

    // Assign auto-increment IDs manually
    const docsWithId = vulnerabilities.map((vuln) => ({
      ...vuln,
      id: startSeq++,
      scanTime: vuln.scanTime || new Date(),
    }));

    const result = await Vulnerability.insertMany(docsWithId, {
      ordered: false,
    });
    // // âœ… Insert all vulnerabilities at once
    // const newVulnerabilities = await Vulnerability.insertMany(
    //   vulnerabilities.map((v) => ({
    //     ...v,
    //     scanTime: v.scanTime || new Date(),
    //   }))
    // );

    res.status(201).json({
      success: true,
      message: `${result.length} vulnerabilities added successfully`,
      data: result,
    });
  } catch (error) {
    console.error("âŒ Bulk upload failed:", error);
    res
      .status(500)
      .json({ message: "Failed to upload vulnerabilities", error });
  }
});



// status changes controller

export const statusChangesController = asyncHandler(async(req, res)=>{
  const { id } = req.params;     // from URL e.g., /api/v1/vulnerability/status/12345
  const { status } = req.body;   // from body e.g., { "status": "Resolved" }

  // Validate input
  if (!status) {
    return res.status(400).json({ message: "Status is required" });
  }

  // Check if the vulnerability exists
  const vulnerability = await Vulnerability.findById(id);

  if (!vulnerability) {
    return res.status(404).json({ message: "Targeted Vulnerability not found" });
  }

  // Update the status
  vulnerability.status = status;
  await vulnerability.save();

  // Send response
  res.status(200).json({
    success: true,
    message: "Status updated successfully",
    data: vulnerability,
  });

})
