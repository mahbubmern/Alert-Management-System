import asyncHandler from "express-async-handler";

import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import {
  generateOTP,
  getPublicID,
  isValidEmail,
  isValidPassword,
  isValidPhoneNumber,
  tokenDecode,
} from "../helpers/helpers.js";
import { Vulnerability, Counter } from "../models/vulnerabilityModel.js";
// import Counter from "../models/counter.js";

//===========================================================

/**
 * @description : vulnerability
 * @method : POST
 * @access : private
 * @route : '/api/v1/auth/vulnerability'
 */

// Allowed lists for validation
const allowedSeverity = ["Low", "Medium", "High", "Critical"];
const allowedStatus = [
  "Open",
  "In Progress",
  "Resolved",
  "Closed",
  "Risk Accepted",
];
const allowedAssetCategory = [
  "Production",
  "Staging",
  "Development",
  "Testing",

  "UAT",
  "Internal Infra",
];
const allowedScanType = [
  "Network Scan",
  "App Scan",
  "Database Scan",
  "Config Scan",
  "Host Scan",
];

export const addVulnerability = asyncHandler(async (req, res) => {
  const {
    name,
    service,
    severity,
    status,
    asset,
    assetCategory,
    osType,
    scanType,
    cve,
    scanner,
    scanTime,
    description,
    remediation,
  } = req.body;

  // ğŸ§© Field validation
  if (
    !name?.trim() ||
    !service?.trim() ||
    !severity?.trim() ||
    !status?.trim() ||
    !asset?.trim() ||
    !assetCategory?.trim() ||
    !osType?.trim() ||
    !scanType?.trim() ||
    !cve?.trim() ||
    !scanner?.trim() ||
    !description?.trim() ||
    !remediation?.trim()
  ) {
    return res.status(400).json({ message: "All fields are required" });
  }

  // ğŸ›‘ ENUM mismatch validation
  if (!allowedSeverity.includes(severity)) {
    return res.status(400).json({
      message: `Invalid severity value. Allowed: ${allowedSeverity.join(", ")}`,
    });
  }

  if (!allowedStatus.includes(status)) {
    return res.status(400).json({
      message: `Invalid status value. Allowed: ${allowedStatus.join(", ")}`,
    });
  }

  if (!allowedAssetCategory.includes(assetCategory)) {
    return res.status(400).json({
      message: `Invalid asset category. Allowed: ${allowedAssetCategory.join(
        ", "
      )}`,
    });
  }

  if (!allowedScanType.includes(scanType)) {
    return res.status(400).json({
      message: `Invalid scan type. Allowed: ${allowedScanType.join(", ")}`,
    });
  }

  try {
    // ğŸ§± Create new vulnerability
    const newVulnerability = await Vulnerability.create({
      name,
      service,
      severity,
      status,
      asset,
      assetCategory,
      osType,
      scanType,
      cve,
      scanner,
      scanTime: scanTime || new Date(),
      description,
      remediation,
    });

    // âœ… Response
    res.status(201).json({
      success: true,
      message: "Vulnerability added successfully",
      data: newVulnerability,
    });
  } catch (error) {
    console.error("âŒ Failed to create vulnerability:", error);
    res.status(500).json({ message: "Failed to create vulnerability", error });
  }
});

// get All vulnerability

// export const getAllVulnerabilityController = asyncHandler(async (req, res) => {
//   const allVulnerability = await Vulnerability.find().sort({ createdAt: -1 });

//   // âœ… Response
//   res.status(200).json({
//     success: true,
//     message: "Vulnerability found successfully",
//     data: allVulnerability,
//   });
// });



// // get All vulnerability
export const getAllVulnerabilityController = async (req, res) => {
  try {
    // 1. Destructure query parameters with defaults
    const {
      page = 1,
      limit = 10,
      search = "",
      service = "Global",
      sortKey = "scanTime", // Default sort by latest scan
      sortDirection = "descending",
    } = req.query;

    // 2. Build the Query Object
    const query = {};

    // Filter by Service (if not Global)
    if (service !== "Global") {
      query.service = service;
    }

    // Global Search Logic
    if (search) {
      const searchRegex = { $regex: search, $options: "i" }; // Case-insensitive
      
      const searchConditions = [
        { name: searchRegex },
        { asset: searchRegex },
        { cve: searchRegex },
        { severity: searchRegex },
        { status: searchRegex },
        { scanner: searchRegex },
      ];

      // If search input is a number, allow searching by your custom 'id'
      if (!isNaN(search)) {
        searchConditions.push({ id: Number(search) });
      }

      query.$or = searchConditions;
    }

    // 3. Handle Sorting
    const sortOptions = {};
    // Map frontend sort keys to DB fields
    sortOptions[sortKey] = sortDirection === "ascending" ? 1 : -1;

    // 4. Calculate Pagination Skip
    const skip = (parseInt(page) - 1) * parseInt(limit);

    // 5. Execute Queries (Parallel execution for speed)
    // We use Promise.all to fetch data and the total count simultaneously
    const [vulnerabilities, totalDocs] = await Promise.all([
      Vulnerability.find(query)
        .sort(sortOptions)
        .skip(skip)
        .limit(parseInt(limit))
        .lean(), // .lean() converts Mongoose docs to plain JS objects (faster)
      Vulnerability.countDocuments(query),
    ]);

    // 6. Send Response
    res.status(200).json({
      success: true,
      data: vulnerabilities,
      meta: {
        totalDocs,
        limit: parseInt(limit),
        totalPages: Math.ceil(totalDocs / parseInt(limit)),
        currentPage: parseInt(page),
      },
    });
  } catch (error) {
    console.error("Error in getVulnerabilities:", error);
    res.status(500).json({
      success: false,
      message: "Server Error fetching vulnerabilities",
      error: error.message,
    });
  }
};

// Get unique services for the dropdown filter
export const getUniqueServices = async (req, res) => {
  try {
    // .distinct() is very fast, even on large datasets
    const services = await Vulnerability.distinct("service");
    
    res.status(200).json({
      success: true,
      data: services,
    });
  } catch (error) {
    console.error("Error fetching services:", error);
    res.status(500).json({
      success: false,
      message: "Server Error fetching services",
    });
  }
};


// GET /api/v1/vulnerability/stats/assets
export const getAssetStats = async (req, res) => {
  try {
    const { service } = req.query;
    const matchStage = {};

    // 1. Filter by service if provided
    if (service && service !== 'Global') {
      matchStage.service = service;
    }

    // 2. Aggregate Data
    const stats = await Vulnerability.aggregate([
      { $match: matchStage },
      {
        $group: {
          _id: "$asset", // Group by Asset Name
          total: { $sum: 1 }, // Count total docs
          nonMitigated: {
            $sum: {
              $cond: [
                { $in: ["$status", ["Open", "In Progress"]] }, // Condition
                1, // If true, add 1
                0  // If false, add 0
              ]
            }
          }
        }
      },
      {
        $project: {
          _id: 0,
          name: "$_id",
          total: 1,
          nonMitigated: 1
        }
      },
      { $sort: { nonMitigated: -1 } } // Sort by highest risk first
    ]);

    res.status(200).json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error("Asset Stats Error:", error);
    res.status(500).json({ success: false, message: "Server Error" });
  }
};

export const bulkAddVulnerability = asyncHandler(async (req, res) => {
  const { vulnerabilities } = req.body;

  if (!Array.isArray(vulnerabilities) || vulnerabilities.length === 0) {
    return res.status(400).json({ message: "No vulnerabilities provided" });
  }

  // ğŸ§© Validate each entry
  for (const vuln of vulnerabilities) {
    const {
      name,
      service,
      severity,
      status,
      asset,
      assetCategory,
      osType,
      scanType,
      cve,
      scanner,
      scanTime,
      description,
      remediation,
    } = vuln;

    if (
      !name?.trim() ||
      !service?.trim() ||
      !severity?.trim() ||
      !status?.trim() ||
      !asset?.trim() ||
      !assetCategory?.trim() ||
      !osType?.trim() ||
      !scanType?.trim() ||
      !cve?.trim() ||
      !scanner?.trim() ||
      !description?.trim() ||
      !remediation?.trim()
    ) {
      return res.status(400).json({
        message: `Missing required field(s) in one of the vulnerabilities`,
      });
    }

    if (!allowedSeverity.includes(severity))
      return res.status(400).json({ message: `Invalid severity: ${severity}` });

    if (!allowedStatus.includes(status))
      return res.status(400).json({ message: `Invalid status: ${status}` });

    if (!allowedAssetCategory.includes(assetCategory))
      return res
        .status(400)
        .json({ message: `Invalid asset category: ${assetCategory}` });

    if (!allowedScanType.includes(scanType))
      return res
        .status(400)
        .json({ message: `Invalid scan type: ${scanType}` });
  }

  try {
    // Get the current counter value
    const counter = await Counter.findByIdAndUpdate(
      { _id: "vulnerabilityId" },
      { $inc: { seq: vulnerabilities.length } },
      { new: true, upsert: true }
    );

    let startSeq = counter.seq - vulnerabilities.length + 1;

    // Assign auto-increment IDs manually
    const docsWithId = vulnerabilities.map((vuln) => ({
      ...vuln,
      id: startSeq++,
      scanTime: vuln.scanTime || new Date(),
    }));

    const result = await Vulnerability.insertMany(docsWithId, {
      ordered: false,
    });
    // // âœ… Insert all vulnerabilities at once
    // const newVulnerabilities = await Vulnerability.insertMany(
    //   vulnerabilities.map((v) => ({
    //     ...v,
    //     scanTime: v.scanTime || new Date(),
    //   }))
    // );

    res.status(201).json({
      success: true,
      message: `${result.length} vulnerabilities added successfully`,
      data: result,
    });
  } catch (error) {
    console.error("âŒ Bulk upload failed:", error);
    res
      .status(500)
      .json({ message: "Failed to upload vulnerabilities", error });
  }
});



// status changes controller

export const statusChangesController = asyncHandler(async(req, res)=>{
  const { id } = req.params;     // from URL e.g., /api/v1/vulnerability/status/12345
  const { status } = req.body;   // from body e.g., { "status": "Resolved" }

  // Validate input
  if (!status) {
    return res.status(400).json({ message: "Status is required" });
  }

  // Check if the vulnerability exists
  const vulnerability = await Vulnerability.findById(id);

  if (!vulnerability) {
    return res.status(404).json({ message: "Targeted Vulnerability not found" });
  }

  // Update the status
  vulnerability.status = status;
  await vulnerability.save();

  // Send response
  res.status(200).json({
    success: true,
    message: "Status updated successfully",
    data: vulnerability,
  });

})
